# 1.1 基础编程模型
## 类型修饰符识别：从变量名开始，由内向外，由右向左
```
int *ptrs[10];
变量ptrs-> [10] 大小为10的数组 ->  int *指向int的指针： 由此ptrs是含有10个整数指针的数组。(由右向左)

int (*Parray)[10] = &arr;
变量Parray -> * 指针 -> [10] 大小为10的数组 -> int 整型： Parray是指向一个10个整数的数组的指针。(由内向外，由右向左)

int *const p1 = &i;
变量p1 -> const常量 -> *指针 -> int整数： p1是整数的常量指针，指针不能被改变，指针指向的整数可以改变。

const int * p2 = &i;
变量p2 -> * 指针  ->  int 整数  -> const常量: p2 是指向整数常量的指针； 指针可以改变，单指针指向的整数不可以改变。
```


## c++数组的特征
- 不允许拷贝

[知乎: 数组为什么不能复制](https://www.zhihu.com/question/27600245/answer/117277247)
```
// 样例
int a[] = {0, 1, 2};
int a2[] = a; // 错误，不允许使用一个数组初始化另一个数组
a2 = a; // 错误，不能把一个数组直接赋值给另一个数组

【原因】
1、历史原因？
    dmr 在 1970s 初发明 C 语言是为了替换汇编语言，以便他和 ken 写操作系统。为了可见性（visibility），
当初 C 语言里每个 operation （包括 operator、function call） 都可以直接翻译为简单的汇编语句（指令），
是 constant time。而数组赋值需要循环，一个 = 操作就不再是 constant time，
这违背了初衷。不如干脆让你自己调用 memcpy 好了，毕竟 memcpy 一眼就能看出它不是 constant time。
这也是 C 语言没有乘方运算符的原因，因为没有对应的汇编指令，实现乘方需要用循环。

2、设计原因
1. 不允许直接复制数组的原因【不是】内存太小。而是为了避免不必要的复制开销，
因为数组的复制将导致连续的内存读与内存写，其【时间】开销取决于数组长度，
有可能会变得非常大。而早期计算机【内存不足】根本就不是原因，
因为如果你确确实实需要复制(比如，将某视频帧复制到显卡视频缓冲区里以显示在屏幕上)，
那该复制就得复制，跑不掉。而这时就必须使用memcpy来显式地完成这个行为。
2. 有人说因为数组和指针【太相像了】，所以就用指针代替了数组。这完全属于【因果倒置】。
其实是为了避免复制数组的开销，才用指针代替数组。
这主要是因为C语言的函数参数传递只有pass by value这一种形式，
而如果对数组采用pass by value的话，在很多时候将导致不必要且巨大的开销。
因此C语言使得当数组作为实参传递给函数的时候，将退化为同类型的指针，然后对那个指针pass by value。


【总结】
数组在编译器里被作为指针看待，数组隐式转化为对应的指向数组首个元素的指针(对应的类型转换称为退化)。
那么此时对于operator=而言，为了维护左操作数作为数组名或对应指针名表现的行为一致，数组在这里退化为指针而不表示整个数组。
而数组退化得到的指针时常量(指针)，因此数组无法作为operator=的左操作数。
```

- 数组会被转换成指针
```
int x[5];
printf("%p\n", x);
printf("%p\n", x+1);
printf("%p\n", &x);
printf("%p\n", &x+1);

查看上面代码的输出：
printf("%p\n", x); x作为数组名，被作为指向数组首元素的地址，同&x[0] : 000000000022fd90

printf("%p\n", x+1); 由于x是指向int的指针，x+1即指针地址为 &x[0] + sizeof(int)*1: 000000000022fd94  

printf("%p\n", &x); &x 是指向大小为5的int数组，地址同x: 000000000022fd90

printf("%p\n", &x+1); &x + 1 等于 &x + sizeof(int) * 5 : 000000000022fda4

```